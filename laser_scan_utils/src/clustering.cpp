/******* DEPRECATED *******/

#include "clustering.h"

#include <fstream>      // std::ofstream



void laserscanutils::LaserDetectionParams::print() const
{
    std::cout << "--------------------------------------------" << std::endl
              << "--  Laser Detection Algorithm Parameters  --" << std::endl
              << "--------------------------------------------" << std::endl
              << "  * Maximum Distance Between Points: " << jump_thr << std::endl
              << "  * Minimum Number of Points for a Cluster: " << min_num_cluster_points << std::endl
              << "  * Maximum Number of Points for a Cluster: " << max_num_cluster_points << std::endl
              << "  * Segmnet Window Size: " << this->segment_window_size << std::endl
              << "  * K_sigmas to tolerate std_dev in line: " << this->k_sigmas << std::endl
              << "  * theta max to concatenate segments: " << this->theta_max_parallel << std::endl;

}




Eigen::MatrixXs laserscanutils::loadScanMatrix()
{
    std::vector<std::vector<float> > values;
    std::ifstream fin("/home/vvaquero/testOneScan2.txt");
    for (std::string line; std::getline(fin, line); )
    {
        std::replace(line.begin(), line.end(), ',', ' ');
        std::istringstream in(line);
        values.push_back(
            std::vector<float>(std::istream_iterator<float>(in),
                                std::istream_iterator<float>()));
    }

    unsigned int rows = values.size();
    unsigned int columns = 0;

    for (unsigned int k = 0; k < rows; k++)
    {
        if (values[k].size() > columns)
            columns = values[k].size();
    }

    std::cout << "Matrix Size = " << rows << "x" << columns  <<std::endl;
    Eigen::MatrixXs result(rows,columns);

    for (unsigned int i = 0; i < rows; i++)
        for (unsigned int j = 0; j < columns; j++)
        {
            result(i,j) = values[i][j];
            //std::cout << "(" << result(i,j) << ") " ;
        }
    return result;
}


void laserscanutils::exportStaticData2Matlab(const char * _file_name,
                                             const LaserDetectionParams & _alg_params)
{
    std::ofstream fileMatlab;
    fileMatlab.open (_file_name, std::ofstream::out); // | std::ofstream::app);

    // FILE HEADER
    fileMatlab << "% ***** Autogenerated File - vvg ***** \n\n";
    fileMatlab << " clc,\n clear all,\n close all \n\n\n";

    // Algorithm Params
    fileMatlab << "% Algorithm Params \n";
    fileMatlab << "alg_detection_params = struct("
                  " 'jump_thr', "                  << _alg_params.jump_thr                 << ","
                  " 'k_sigmas', "                  << _alg_params.k_sigmas                 << ","
                  " 'segment_window_size', "       << _alg_params.segment_window_size      << ","
                  " 'theta_max_parallel', "        << _alg_params.theta_max_parallel       << ","
                  "'min_num_cluster_points', "     << _alg_params.min_num_cluster_points    << ","
                  "'max_num_cluster_points', "     << _alg_params.max_num_cluster_points    << "); \n\n";

    // Algorithm Stats skeleton
    fileMatlab << "% Algorithm Stats skeleton \n" ;
    fileMatlab << "alg_detection_stats = struct([]); \n\n";

    // Global Odometry skeleton
    fileMatlab << "% Global Odometry skeleton\n" ;
    fileMatlab << "global_odom = struct([]); \n\n";


    // Object List skeleton
    fileMatlab << "% Object List skeleton \n" ;
    fileMatlab << "object_list = struct('lineList',[]);\n";
    fileMatlab << "object_list.lines = cell([1]);\n\n";
    //fileMatlab << "object_list.lineList = struct([]);\n\n";


    // Scan Matrix Homogeneous Coordinates
    fileMatlab << "% Scan Matrix In Homogeneous Coordinates \n" ;
    fileMatlab << "scanMatrixHomo = struct([]);\n\n";

    // Rotation Matrix
    fileMatlab << "% Rotation Matrix \n" ;
    fileMatlab << "alfa = pi/2; \n";
    fileMatlab << "rotateM = [cos(alfa), -sin(alfa); sin(alfa), -cos(alfa)]; \n";


    fileMatlab.close();

}

void laserscanutils::exportData2Matlab(std::string & _file_name,
                                       const Eigen::MatrixXs & _points,
                                       LaserDetectionStats & _stats,
                                       unsigned int _scanNumber)
{
    std::ofstream fileMatlab;

    std::string new_name;
    int division = _scanNumber/100;
//    if (division == 0)
//    {
        int cociente = _scanNumber/100;
        new_name = _file_name + std::to_string(division);
        new_name += ".m";
        fileMatlab.open (new_name, std::ofstream::out | std::ofstream::app);
//    }

    // FILE HEADER
    fileMatlab << "% ***** Autogenerated File - vvg ***** \n\n";
    //fileMatlab << " clc,\n clear all,\n close all \n\n\n";


    // Algorithm Status Variables
    fileMatlab << "% Algorithm Status Variables \n";
    fileMatlab << "alg_detection_stats("  << _scanNumber << ").filteredTotalPoints = " << _stats.filteredTotalPoints   << "; \n";
    fileMatlab << "alg_detection_stats("  << _scanNumber << ").numberOfClusters = " << _stats.numberOfClusters   << "; \n";
    fileMatlab << "alg_detection_stats("  << _scanNumber << ").numberOfValidClusters = " << _stats.numberOfValidClusters   << "; \n";
    fileMatlab << "alg_detection_stats("  << _scanNumber << ").scanTotalPoints = " << _stats.scanTotalPoints   << "; \n";
    fileMatlab << "alg_detection_stats("  << _scanNumber << ").cluster_indxs = [";
    for (unsigned int cluster = 0; cluster < _stats.cluster_indxs_.size(); cluster++)
    {
        std::pair<int,int> tempCluster = _stats.cluster_indxs_[cluster];
        fileMatlab << tempCluster.first << "; " << tempCluster.second << "; ";
    }
    fileMatlab << "]; \n";

    fileMatlab << "alg_detection_stats("  << _scanNumber << ").cluster_indxs = reshape( alg_detection_stats("  << _scanNumber <<
                  ").cluster_indxs,[2,length(alg_detection_stats("  << _scanNumber << ").cluster_indxs)/2]); \n\n";


    // Scanner Points in Homogeneous coordinates
    fileMatlab << "% Writing Scanner Points in Homogeneous coordinates \n";
    fileMatlab << "scanMatrixHomo("  << _scanNumber << ").scan = [";
    for (unsigned int row = 0; row < 3; row++)
    {
        for (unsigned int col = 0; col < _stats.filteredTotalPoints; col++)
        {
          fileMatlab << _points(row,col) << " ";
        }
        fileMatlab << ";\n";
    }
    fileMatlab << "]; \n\n";



//    // Global Odometry
    fileMatlab << "% Global Odometry \n";
    fileMatlab << "global_odom("  << _scanNumber << ").position = [" << _stats.odom_pos_[0] << ", " <<
                                                                        _stats.odom_pos_[1] << ", " <<
                                                                        _stats.odom_pos_[2] << "]; \n";
    fileMatlab << "global_odom("  << _scanNumber << ").orientation = [" <<  _stats.odom_ori_[0] << ", " <<
                                                                            _stats.odom_ori_[1] << ", " <<
                                                                            _stats.odom_ori_[2] << ", " <<
                                                                            _stats.odom_ori_[3] << "]; \n";


//    // Rotating Points Matrix
//    fileMatlab << "% Rotating Points Matrix \n";
//    fileMatlab << "scanMatrixHomo("  << _scanNumber << ").scanRot = scanMatrixHomo(1:2, :); \n" ;
//    fileMatlab << "scanMatrixHomo("  << _scanNumber << ").scanRot = rotateM*scanMatrixHomo("  << _scanNumber << ").scanRot; \n\n";


//    // Drawing Rotated Scan
//    fileMatlab << "% Drawing Rotated Scan \n";
//    fileMatlab << "scatter(scanMatrixRot(1,:), scanMatrixRot(2,:),30,'filled'); axis equal; grid on; \n\n";



    // Printing Full Objects
    fileMatlab << "% Printing Full Objects \n";

    fileMatlab << "% Object n\n";
    std::list<laserscanutils::Object>::iterator object_it = _stats.object_list_.begin();
    for (; object_it != _stats.object_list_.end(); object_it++)
    {
        laserscanutils::Object temp_object = *object_it;

        // Object
        fileMatlab << "object_list(" << _scanNumber << ").numberOfPoints(" << std::distance(_stats.object_list_.begin(),object_it)+1 << ") =  "
                   << temp_object.num_points_<< ";\n";

        fileMatlab << "object_list(" << _scanNumber << ").first(" << std::distance(_stats.object_list_.begin(),object_it)+1 << ") = "
                   << temp_object.first_ << ";\n";

        fileMatlab << "object_list(" << _scanNumber << ").last(" << std::distance(_stats.object_list_.begin(),object_it)+1 << ") = "
                   << temp_object.last_ << ";\n";

        fileMatlab << "object_list(" << _scanNumber << ").tracked(" << std::distance(_stats.object_list_.begin(),object_it)+1 << ") = "
                   << temp_object.associated_ << ";\n";

//        fileMatlab << "object_list(" << _scanNumber << ").lineList(" << std::distance(_stats.object_list_.begin(),object_it)+1 << ") = [";
        fileMatlab << "object_list(" << _scanNumber << ").lineList = [object_list(" << _scanNumber << ").lineList; ";
        for (std::list<laserscanutils::Line>::iterator line_it = temp_object.line_list_.begin(); line_it != temp_object.line_list_.end(); line_it++)
        {
            laserscanutils::Line temp_line = *line_it;

            //std::cout << temp_line.point_first_.transpose() << "," << temp_line.point_last_.transpose() << ", " << temp_line.error_ << std::endl;
            fileMatlab << temp_line.point_first_(0) << ", " << temp_line.point_first_(1) << ", " << temp_line.point_first_(2) << ", " <<
                         temp_line.point_last_(0) << ", "  << temp_line.point_last_(1)  << ", " << temp_line.point_last_(2)  << ", " <<
                         temp_line.error_ << ", " << temp_line.vector_(0) << ", " << temp_line.vector_(1) << ", " << temp_line.vector_(2) <<";\n";
        }
        fileMatlab << "];\n";

        fileMatlab << "object_list(" << _scanNumber << ").lines{" << std::distance(_stats.object_list_.begin(),object_it)+1 << ",1} = [";

        for (std::list<laserscanutils::Line>::iterator line_it = temp_object.line_list_.begin(); line_it != temp_object.line_list_.end(); line_it++)
        {
            laserscanutils::Line temp_line = *line_it;

            //std::cout << temp_line.point_first_.transpose() << "," << temp_line.point_last_.transpose() << ", " << temp_line.error_ << std::endl;
            fileMatlab << temp_line.point_first_(0) << ", " << temp_line.point_first_(1) << ", " << temp_line.point_first_(2) << ", " <<
                         temp_line.point_last_(0) << ", "  << temp_line.point_last_(1)  << ", " << temp_line.point_last_(2)  << ", " <<
                         temp_line.error_ << ", " << temp_line.vector_(0) << ", " << temp_line.vector_(1) << ", " << temp_line.vector_(2) <<";\n";
        }
        fileMatlab << "];\n";

    }


    fileMatlab.close();
}










//****************************************************
//**********     preFilterScan
//****************************************************
void laserscanutils::preFilterScan(const laserscanutils::ScanParams & _params,
                                   const std::vector<float> & _ranges,
                                   Eigen::MatrixXs & _points,
                                   laserscanutils::LaserDetectionStats &_stats)
{
    std::cout << "[PreFiltering SCAN... ";

//    std::cout << "Points Matrix = " << _points.rows() << "x" << _points.cols() << std::endl;

//    std::cout << "Matrix:" << std::endl << _points << std::endl;

    unsigned int matPosition = 0;
    float act_range = -1;
    float act_theta = 0.0;

    for(unsigned int i=0; i<_ranges.size(); ++i)
    {
        act_range = _ranges[i];

        if ( (act_range >=_params.range_min_) && (act_range <= _params.range_max_) && !(std::isnan(act_range)) && !(std::isinf(act_range))  )
        {
            act_theta = _params.angle_min_+ _params.angle_step_*(i);

            _points.col(matPosition) << act_range*cos(act_theta), act_range*sin(act_theta), 1;

            matPosition++;
        }
        else
        {
            //std::cout << "Invalid Point: " << scan.ranges[i] << " - index: " << i << std::endl;
        }


    }  // END FOR scan ranges

    // Filling stats
    _stats.scanTotalPoints = _ranges.size();
    _stats.filteredTotalPoints = matPosition;

    //std::cout << "..DONE] " << std::endl;
}






////****************************************************
////**********     findClusters
////****************************************************
//void laserscanutils::findClusters(const laserscanutils::LaserObjectDetAlgParams &_alg_params,
//                          const Eigen::MatrixXs & _points,
//                          LaserDetectionStats & _stats)
//{

//    _stats.cluster_indxs_.clear();
//    _stats.object_list_.clear(); // Assure the object list for the scan is empty.

//    std::pair<int,int> seg;      // saves the first and last point for each segment
//    laserscanutils::Object temp_object; // objects detected initialization.

//    float points_distance = 0.0;
//    int count_num_cluster = 0;
//    int count_num_valid_cluster = 0;


//    // Initial Segment
////    count_num_cluster = 1;
//    seg.first = 0;
//    float sq_threshold = pow(_alg_params.jump_thr,2.0);

//    //for (unsigned int col = 1; col < _points.cols(); col++)
//    for (unsigned int col = 1; col < _stats.filteredTotalPoints; col++)
//    {
//        points_distance = ( pow( ( _points(0,col) -_points(0,col-1) ), 2.0 ) + pow( ( _points(1,col) - _points(1,col-1) ), 2.0) );

//        if ( points_distance <=  sq_threshold)  // same segment points
//        {
//          // Same segment -> TODO counter?
//        }

//        else // if ( col != _points.cols() )      // new segment
//        {
//            //std::cout << "P " << pos << " - A - (" << pointA.x << "-" << pointA.y << ") - B - (" << pointB.x << "-" << pointB.y << ") -> distance: " << points_distance << " More Than th" << std:endl;

//            seg.second = col-1;                     // end of the previous segment

//            // check length of the cluster
//            if ( ( (seg.second - seg.first)+1 >= _alg_params.min_num_cluster_points ) && ( (seg.second - seg.first)+1 <= _alg_params.max_num_cluster_points) )
//            {
//                _stats.cluster_indxs_.push_back(seg);

//                // fulfill and add object
//                temp_object.first_ = seg.first;
//                temp_object.last_  = seg.second;
//                temp_object.num_points_ = seg.second - seg.first +1;
//                _stats.object_list_.push_back(temp_object);

//                count_num_valid_cluster++;    // count cluster as valid
//                //std::cout << "CLUSTER IS VALID" <<  std::endl;
//            }
//            // TODO: else: save the invalid cluster in other vector of bad clusters to further analysis
//            count_num_cluster++;    // count any cluster

//            seg.first = col;
//        }

//    }
//    // last point close last segment
////    seg.second = _points.cols()-1;
//    seg.second = _stats.filteredTotalPoints-1;
//    if (seg.second - seg.first >= _alg_params.min_num_cluster_points && seg.second - seg.first <= _alg_params.max_num_cluster_points)
//    {
//        _stats.cluster_indxs_.push_back(seg);

//        // fulfill and add object
//        temp_object.first_ = seg.first;
//        temp_object.last_  = seg.second;
//        temp_object.num_points_ = seg.second - seg.first +1;
//        _stats.object_list_.push_back(temp_object);

//        count_num_valid_cluster++;    // count cluster as valid
//        //std::cout << "CLUSTER IS VALID" <<  std::endl;
//    }
//    count_num_cluster++;    // count any cluster


//    // Stats
//    _stats.numberOfClusters = count_num_cluster;
//    _stats.numberOfValidClusters = count_num_valid_cluster;

//    std::cout << "numberOfValidClusters = " << count_num_valid_cluster << std::endl;
//    std::cout << "Number of OBJECTS prepared = " << _stats.object_list_.size() << std::endl;



//}





//void laserscanutils::findLinesInCluster(const laserscanutils::ScanParams & _params,
//                                         const laserscanutils::LaserDetectionParams & _alg_params,
//                                         const Eigen::MatrixXs & _cluster,
//                                         const unsigned int initIndex,
//                                         std::list<laserscanutils::Line> & _line_list)
//{
//    laserscanutils::Line line;
//    std::list<Line>::iterator line_it1, line_it2;
//    ScalarT theta;

//    // cleaning line_list
//    _line_list.clear();

//    //init random generator
//    std::default_random_engine generator(1);
//    std::uniform_int_distribution<int> rand_window_overlapping(1,_alg_params.segment_window_size);

//    //std::cout << "TEST!!!!:  = _cluster.cols() = " << _cluster.cols() << std::endl;

//    unsigned int ii = _alg_params.segment_window_size-1;
//    bool last = false;
//    //while ( (ii<_cluster.cols()) && (last != true) )
//    while (last != true)
//    {
//        if (ii >= _cluster.cols())
//        {
//            //std::cout << " LAST " << std::endl;
//            ii = _cluster.cols()-1;
//            last = true;
//        }
//        unsigned int i_from = ii - _alg_params.segment_window_size + 1;

//        //std::cout << "Fitting Line: from " << i_from << " to " << ii << "...";
//        fitLine(_cluster.block(0,i_from, 3, _alg_params.segment_window_size), line);

//        //if error below stdev, add line to result set
//        if ( line.error_ < _params.range_std_dev_*_alg_params.k_sigmas )
//        {
//            //std::cout << "=> YES!" << std::endl;
//            line.first_ = i_from;
//            line.last_ = ii;
//            line.point_first_ = _cluster.col(line.first_);
//            line.point_last_ = _cluster.col(line.last_);
//            line.np_ = line.last_ - line.first_ + 1;

//            _line_list.push_back(line);
//        }
//        else
//        {
//            //std::cout << " NO! - Error = " << line.error_ << " > " << _params.range_std_dev_*_alg_params.k_sigmas << std::endl;
//            //std::cout << "  List of points: " ;
////            for (unsigned int po = i_from;  po < ii; po++)
////            {
////                std::cout << "[" << _cluster(0,po) << ", " << _cluster(1,po) << "], ";
////            }
////            std::cout << std::endl;
//        }
//        ii = ii+rand_window_overlapping(generator);
//    }

//    std::cout << "Lines fitted: " << _line_list.size();


//    // concatenating lines
//    line_it1 = _line_list.begin();

//    while ( line_it1 != _line_list.end() )
//    {
//        line_it2 = line_it1;
//        line_it2 ++;
//        while (line_it2 != _line_list.end())
//        {
//            //compute angle between lines 1 and 2
//            theta = laserscanutils::angleBetweenLines(*line_it1, *line_it2);

////            std::cout << "LineIt1 = " << std::distance(_line_list.begin(),line_it1) << " vs LineIt2 = " << std::distance(_line_list.begin(), line_it2) << std::endl;
////            std::cout << "cos_theta: " << cos(theta) << " -> theta: " << theta << std::endl;

//            //Check angle threshold
//            if ( theta < _alg_params.theta_max_parallel ) //fabs(theta) not required since theta>0
//            {
//                //compute a new line with all involved points
//                Line new_line;
//                fitLine(_cluster.block(0,line_it1->first_, 3, line_it2->last_-line_it1->first_+1), new_line);
////                std::cout << "  Checking Concatenation error of : " << line_it1->first_ << " vs " << line_it2->last_ << std::endl;
////                std::cout << "   New Line error : " << new_line.error_ << " <=? " << _params.range_std_dev_*_alg_params.k_sigmas << std::endl;


//                //check if error below a threshold to effectively concatenate
//                if ( new_line.error_ < _params.range_std_dev_*_alg_params.k_sigmas )
//                {
//                    //std::cout << "   => lines concatenated";

//                    //update line1 as the concatenation of l1 and l2
//                    new_line.first_ = line_it1->first_;
//                    new_line.last_ = line_it2->last_;
//                    new_line.point_first_ = line_it1->point_first_;
//                    new_line.point_last_ = line_it2->point_last_;
//                    new_line.np_ = new_line.last_ - new_line.first_ + 1;
//                    *line_it1 = new_line;

//                    //remove l2 from the list
//                    line_it2 = _line_list.erase(line_it2);

//                    //std::cout << " - line resultant: from "<< new_line.first_ << " to " << new_line.last_ << std::endl;
//                    //<< new_line.vector_.transpose() <<  "    ERROR: " << new_line.error_ << std::endl << std::endl;

//                    //in that case do not update iterators to allow concatenation of the new l1 with the next line in the list, if any
//                   // update_iterators = false;
//                }
//                else
//                {
//                    line_it2++;
//                    //std::cout << "  <-- no concatenation...error too big" << std::endl;
//                }
//            }
//            else
//            {
//                line_it2++;
//                //std::cout << "  <-- no concatenation... theta too big " << std::endl;
//            }

//        } // end while it 2

//        // Eliminating intermediate lines
//        std::list<Line>::iterator temp_line_it = line_it1;
//        line_it1++;
//        while ( (temp_line_it->last_ >= line_it1->first_) && (line_it1 != _line_list.end()))
//        {
//            //std::cout << " linea intermedia!" << std::endl;
//            line_it1 = _line_list.erase(line_it1);
////            line_it1++;
//        }


//    }  // end while it 1

//    // globalizing first and last point (in terms of the whole scan)
//    for (auto list_it1 = _line_list.begin(); list_it1 != _line_list.end(); list_it1++)
//    {
//        //std::cout << " INSIDE FIND LINES #." << std::distance(_line_list.begin(),list_it1) << std::endl;
//        list_it1->first_ += initIndex;
//        list_it1->last_ += initIndex;
//        //list_it1->print();
//        //std::cout << std::endl << std::endl;
//    }

//    std::cout << " --> Lines After Concatenation: " << _line_list.size() << std::endl << std::endl;


//}










//unsigned int laserscanutils::findCornersInClusterLines(const laserscanutils::ScanParams & _params,
//                                                       const ExtractCornerParams & _alg_params,
//                                                       const std::list<laserscanutils::Line> & _line_list,
//                                                       std::list<laserscanutils::Corner> & _corner_list)
//{
//    //local variables
//    ScalarT theta;
//    Corner corner;
//    std::list<Line>::const_iterator line_it1, line_it2, line_it3, last_line;
//    std::list<laserscanutils::Corner>::iterator corner_it1, corner_it2;
//    ScalarT max_distance_sq(_alg_params.line_params_.jump_dist_ut_*_alg_params.line_params_.jump_dist_ut_); //init max distance as the squared value to avoid sqroot on comparisons

//    //std::cout << "CORNER DETECTION FROM LINES: " << std::endl;
//    //  _alg_params.print();

//    line_it1 = _line_list.begin();

//    if (_line_list.size() <2)
//    {
//        //std::cout << "DEBUG: --> NOT ENOUGH LINES IN CLUSTER TO EXTRACT CORNERS" << std::endl;
//        return 0;
//    }

//    while ( line_it1 != _line_list.end()--)
//    {
//        line_it2 = line_it1;
//        line_it2 ++;


//        //    std::cout << std::endl << "line 1: last idx: " << (int)line_it1->last_ << std::endl;
//        //    std::cout << "line 2: first idx: " << (int)line_it2->first_ << std::endl;
//        //    std::cout << "substraction " << static_cast<int>(line_it2->first_) - (int)line_it1->last_ << std::endl;

//        //        std::cout << "line 1: point first: " << line_it1->point_first_.transpose() << std::endl;
//        //        std::cout << "line 1: point last: " << line_it1->point_last_.transpose() << std::endl;
//        //        std::cout << "line 2: point first: " << line_it2->point_first_.transpose() << std::endl;
//        //        std::cout << "line 2: point last: " << line_it2->point_last_.transpose() << std::endl;

//        //compute angle between lines 1 and 2
//        theta = angleBetweenLines(*line_it1, *line_it2);
//        std::cout << "Angle Between Lines #" << std::distance(_line_list.begin(),line_it1) << " - "
//                     << std::distance(_line_list.begin(),line_it2) << " = " << theta;

//        //Check angle threshold
//        if ( theta > _alg_params.theta_min_ )
//        {
//            std::cout << "  ... Corner! : " << std::endl;
//            // Find the corner as the cross product between lines (intersection of lines in homog)
//            corner.pt_ = (line_it1->vector_).cross(line_it2->vector_);

//            // normalize corner point to set last component to 1
//            corner.pt_ = corner.pt_ / corner.pt_(2);

//            // Check if the corner is close to both lines ends. TODO: Move this check before computing intersection
//            if ( (line_it1->point_last_ - corner.pt_).head(2).squaredNorm() < max_distance_sq
//                 &&
//                 (line_it2->point_first_ - corner.pt_).head(2).squaredNorm() < max_distance_sq )
//            {
//                std::cout << "      Corners is close enough: " << std::endl;

//                //vector from corner to first point of l1
//                Eigen::Vector2s v1 = line_it1->point_first_.head(2) - corner.pt_.head(2);

//                //compute corner orientation as the angle between v1 and local X, in [-pi,pi]
//                corner.orientation_ = atan2(v1(1),v1(0));

//                //Compute corner aperture with line_it1->first, corner and line_it2->last
//                corner.aperture_ = cornerAperture(line_it1->point_first_, corner.pt_, line_it2->point_last_);

//                //set other descriptors
//                corner.line_1_ = *line_it1;
//                corner.line_2_ = *line_it2;

//                //add the corner to the list
//                _corner_list.push_back(corner);

//                // debug: print
//                corner.print();
//            }
//        }
//        else
//            //std::cout << "  ... No Corner! : " << std::endl;

//        line_it2 ++;
//        line_it1 ++;


//    }
//    //std::cout << "Corners extracted: " << _corner_list.size() << std::endl;

////    // Erase duplicated corners
////    corner_it1 = _corner_list.begin();
////    while ( corner_it1 != _corner_list.end() )
////    {
////        corner_it2 = corner_it1;
////        corner_it2 ++;
////        while (corner_it2 != _corner_list.end())
////        {
////            // Check if two corners are close enough. TODO: Check othe attributes also (orientation and aperture) !
////            if ( ( corner_it1->pt_ - corner_it2->pt_ ).head(2).squaredNorm() < max_distance_sq )
////            {
////                // Keep the one with bigger product of number of points of each line
////                (*corner_it1) = (corner_it1->line_1_.np_*corner_it1->line_2_.np_ > corner_it2->line_1_.np_*corner_it2->line_2_.np_? *corner_it1 : *corner_it2);
////                corner_it2 = _corner_list.erase(corner_it2);
////            }
////            else
////                corner_it2 ++;
////        }
////        corner_it1 ++;
////    }
//    //std::cout << "Corners after removing duplicates: " << _corner_list.size() << std::endl;

//    //  for(std::list<laserscanutils::Corner>::iterator corner_it1 = _corner_list.begin(); corner_it1 != _corner_list.end(); corner_it1++)
//    //    corner_it1->print();

//    return _corner_list.size();
//}







// NOT USED!!!!
// VV - Converts ranges from a laserScan to homogeneous coordinates and save it to a matrix of same size than ranges size, returning index till valid values.
unsigned int laserscanutils::scanProcess(const ScanParams & _params,
                                         const std::vector<float> & _ranges,
                                         const float _jump_threshold,
                                         Eigen::MatrixXs & _points,
                                         std::vector<unsigned int> & _jumps_id_)
{

  _jumps_id_.clear();

  unsigned int matPosition = 0;
  float prev_range = -1;
  float prev_theta = 0;
  float act_range = -1;
  float act_theta = 0.0;

  float distance = 0;

  for(unsigned int i=0; i<_ranges.size(); ++i)
  {
    act_range = _ranges[i];
    if ( (act_range >=_params.range_min_) && (act_range <= _params.range_max_) && !(std::isnan(act_range)) && !(std::isinf(act_range))  )
    {
      act_theta = _params.angle_min_+ _params.angle_step_*(i);

      _points.col(matPosition) << act_range*cos(act_theta), act_range*sin(act_theta), 1; //row0-> x coordinate, row1->y coordinate, row2->1;
      matPosition++;

      // Calculating end of clusters
      if (prev_range != -1)
      {
        // polar distances = r2² + r1² - 2*r1*r2*cos(theta2-theta1)
        distance = act_range*act_range + prev_range*prev_range - (2*prev_range*act_range*(cos(prev_theta-act_theta)));

        if (distance > _jump_threshold  &&  1==1) // TODO Add option of measure number of invalid point in between.
          _jumps_id_.push_back(matPosition);
      }
      prev_range = act_range; // updates
      prev_theta = act_theta;

    }
    else
    {
      //std::cout << "Invalid Point: " << _ranges[i] << " - index: " << i << std::endl;
    }

  }//END for

  return matPosition-1; // Remap the vector to the Matrix - Accounting for 0


}







// VV - test to check results in txt
void laserscanutils::printMatrixAndClusters2File(std::string &_file_name,
                                                const unsigned int _num_points,
                                                Eigen::MatrixXs & _points,
                                                std::vector< std::pair<int,int> > _cluster_indxs_)
{
    std::ofstream filePoints;
    std::string namePoints = _file_name.append("_points.txt");
    filePoints.open(namePoints , std::ofstream::out | std::ofstream::app);

    for (unsigned int row = 0; row < 3; row++)
    {
        for (unsigned int col = 0; col < _num_points; col++)
        {
          filePoints << _points(row,col) << ",";
        }
        filePoints << "\n";
    }
    filePoints.close();


    std::ofstream fileSegments;
    fileSegments.open (_file_name.append("_clusters.txt"), std::ofstream::out | std::ofstream::app);
    for (auto segnum_it = _cluster_indxs_.begin(); segnum_it != _cluster_indxs_.end(); segnum_it++)
    {
        std::pair<int,int> tem_inds = *segnum_it;
        fileSegments << tem_inds.first << ", " << tem_inds.second <<  "\n";
    }
    fileSegments.close();
}



// VV - test to check results in txt
void laserscanutils::printLinesToFile(std::string &_file_name, std::list<laserscanutils::Line> & _line_list)
{
    std::ofstream fileLines;
    fileLines.open(_file_name , std::ofstream::out | std::ofstream::app);

    for (std::list<laserscanutils::Line>::iterator line_it = _line_list.begin(); line_it != _line_list.end(); line_it++)
    {
        laserscanutils::Line temp_line = *line_it;

        std::cout << temp_line.point_first_.transpose() << "," << temp_line.point_last_.transpose() << ", " << temp_line.error_ << std::endl;
        fileLines << temp_line.point_first_(0) << ", " << temp_line.point_first_(1) << ", " << temp_line.point_first_(2) << ", " <<
                     temp_line.point_last_(0) << ", "  << temp_line.point_last_(1)  << ", " << temp_line.point_last_(2)  << ", " <<
                     temp_line.error_ << "\n";
    }
    fileLines << "0, 0, 0, 0, 0, 0, 0\n";
    fileLines.close();

}





// VV - test to check results in txt
void laserscanutils::printMatrix2FileJumpsVersion(char *_file_name, const unsigned int _num_points,
               Eigen::MatrixXs & _points,
               std::vector<unsigned int> & _jumps_id_)
{
    std::ofstream filePoints;
    filePoints.open (std::strcat(_file_name, "_points.txt") , std::ofstream::out | std::ofstream::app);

    // TO PRINT IN ONE ROW
//    for (int numpoint = 0; numpoint < _num_points; numpoint++)
//    {
//      filePoints << _points.col(numpoint) << "\n";
//    }
//    filePoints.close();

    for (unsigned int row = 0; row < 3; row++)
    {
        for (unsigned int col = 0; col < _num_points; col++)
        {
          filePoints << _points(row,col) << ",";
        }
        filePoints << "\n";
    }
    filePoints.close();


    std::ofstream fileSegments;
    fileSegments.open (std::strcat(_file_name, "_points.txt"), std::ofstream::out | std::ofstream::app);
    for (unsigned int segnum = 1; segnum<_jumps_id_.size(); segnum++)
    {
        if (segnum == 1)
            fileSegments << "Segment Number: 0 - from 0 " << " to " << _jumps_id_[segnum] <<  "\n";
        else
            fileSegments << "Segment Number: "<< segnum << " - from " << _jumps_id_[segnum-1] << " to " << _jumps_id_[segnum] <<  "\n";
    }
    fileSegments.close();
    //std::cout << "PRINTING OUT " << std::endl;
}















