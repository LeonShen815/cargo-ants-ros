#include "object_detector.h"


#include <fstream>      // std::ofstream




void laserscanutils::LaserObjectDetAlgParams::print() const
{
    std::cout << "---------------------------------------------------" << std::endl
              << "--  Laser Object Detection Algorithm Parameters  --" << std::endl
              << "---------------------------------------------------" << std::endl
              << "  * Maximum Distance Between Points: " << this->cluster_jump_thr_ << std::endl
              << "  * Minimum Number of Points for a Cluster: " << this->cluster_min_num_points_ << std::endl
              << "  * Maximum Number of Points for a Cluster: " << this->cluster_max_num_points_ << std::endl
              << "  * Segmnet Window Size: " << this->fit_line_window_size_ << std::endl
              << "  * K_sigmas to tolerate std_dev in line: " << this->fit_line_k_sigmas_ << std::endl
              << "  * theta max to concatenate segments: " << this->fit_line_theta_max_parallel_ << std::endl;

}



//****************************************************
//**********     PRINT TO MATLAB TESTS
//****************************************************
void laserscanutils::exportStaticScanProcessed2Matlab(const char * _file_name,
                                                      const LaserObjectDetAlgParams &_alg_params,
                                                      const LaserScanProcessed &_scan_processed)
{
    std::ofstream fileMatlab;
    fileMatlab.open (_file_name, std::ofstream::out); // | std::ofstream::app);

    // FILE HEADER
    fileMatlab << "% ***** Autogenerated File - vvg ***** \n\n";
    fileMatlab << " clc,\n clear all,\n close all \n\n\n";

    // Algorithm Params
    fileMatlab << "% Algorithm Params \n";
    fileMatlab << "alg_detection_params = struct("
                  " 'cluster_jump_thr_', "              << _alg_params.cluster_jump_thr_                << ","
                  " 'cluster_max_num_points_', "        << _alg_params.cluster_max_num_points_          << ","
                  " 'cluster_min_num_points_', "        << _alg_params.cluster_min_num_points_          << ","
                  " 'corner_theta_min_', "              << _alg_params.corner_theta_min_                << ","
                  "'fit_line_k_sigmas_', "              << _alg_params.fit_line_k_sigmas_               << ","
                  "'fit_line_theta_max_parallel_', "    << _alg_params.fit_line_theta_max_parallel_     << ","
                  "'fit_line_window_size_', "           << _alg_params.fit_line_window_size_            << ","
                  "'tf_scan_window_size_', "            << _alg_params.tf_scan_window_size_             << "); \n\n";

    // Laser Scan Processed skeleton
    fileMatlab << "% Laser Scan Processed skeleton \n" ;
    fileMatlab << "scan_processed = cell([1]); \n\n";
//    fileMatlab << "scan_processed = struct(
//                  "'name_', "       << _scan_processed.cluster_indxs_); \n\n";

////    // Global Odometry skeleton
////    fileMatlab << "% Global Odometry skeleton\n" ;
////    fileMatlab << "global_odom = struct([]); \n\n";


//    // Object List skeleton
//    fileMatlab << "% Object List skeleton \n" ;
//    fileMatlab << "object_list = struct('lineList',[]);\n";
//    fileMatlab << "object_list.lines = cell([1]);\n\n";
//    //fileMatlab << "object_list.lineList = struct([]);\n\n";


//    // Scan Matrix Homogeneous Coordinates
//    fileMatlab << "% Scan Matrix In Homogeneous Coordinates \n" ;
//    fileMatlab << "scanMatrixHomo = struct([]);\n\n";

//    // Rotation Matrix
//    fileMatlab << "% Rotation Matrix \n" ;
//    fileMatlab << "alfa = pi/2; \n";
//    fileMatlab << "rotateM = [cos(alfa), -sin(alfa); sin(alfa), -cos(alfa)]; \n";


    fileMatlab.close();

}


void laserscanutils::exportDataScanProcessed2Matlab(std::string &_file_name,
                                                    LaserScanProcessed & _scan_processed)
{
    std::ofstream fileMatlab;

    std::string new_name;
    int division = _scan_processed.id_/100;
    new_name = _file_name + std::to_string(division);
    new_name += ".m";
    fileMatlab.open (new_name, std::ofstream::out | std::ofstream::app);


    // FILE HEADER
    fileMatlab << "% ***** Autogenerated File 2 - vvg ***** \n\n";
    //fileMatlab << " clc,\n clear all,\n close all \n\n\n";


    // Laser Scan Processed
    fileMatlab << "% Laser Scan Processed Variables \n";
    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.id_ = " << _scan_processed.id_   << "; \n\n";
    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.scan = [";
    for (unsigned int row = 0; row < 3; row++)
    {
        for (unsigned int col = 0; col < _scan_processed.filtered_total_points_; col++)
        {
          fileMatlab << _scan_processed.scan_points_matrix_(row,col) << " ";
        }
        fileMatlab << ";\n";
    }
    fileMatlab << "]; \n\n";

    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.cluster_indxs_ = [";
    for (unsigned int cluster = 0; cluster < _scan_processed.cluster_indxs_.size(); cluster++)
    {
        std::pair<int,int> tempCluster = _scan_processed.cluster_indxs_[cluster];
        fileMatlab << tempCluster.first << "; " << tempCluster.second << "; ";
    }
    fileMatlab << "]; \n\n";

    // Objects
    unsigned int object_count = 0;
    for (auto& temp_object  : _scan_processed.object_list_)
    {
        object_count += 1;
        // Object
        fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.tracked = "
                   << temp_object.id_        << ";\n";
        fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.num_points = "
                   << temp_object.num_points_  << ";\n";
        fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.first_idx = "
                   << temp_object.first_        << ";\n";
        fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.last_idx = "
                   << temp_object.last_          << ";\n";

        unsigned int line_counter = 0;
        for (auto& temp_line : temp_object.line_list_)
        {
            line_counter += 1;
            // lines of the object
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.line_list{";
            fileMatlab  <<  line_counter   << "}.vector = ["
                        << temp_line.vector_(0) << "," << temp_line.vector_(1) << "," << temp_line.vector_(2) << "]; \n";
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.line_list{";
            fileMatlab  <<  line_counter   << "}.point_first = ["
                        << temp_line.point_first_(0) << "," << temp_line.point_first_(1) << "," << temp_line.point_first_(2) << "]; \n";
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.line_list{";
            fileMatlab  <<  line_counter   << "}.point_last = ["
                        << temp_line.point_last_(0) << "," << temp_line.point_last_(1) << "," << temp_line.point_last_(2) << "]; \n";
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.line_list{";
            fileMatlab  <<  line_counter   << "}.error = " << temp_line.error_ << ";\n";
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.line_list{";
            fileMatlab  <<  line_counter   << "}.first_idx = " << temp_line.first_ << ";\n";
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.line_list{";
            fileMatlab  <<  line_counter   << "}.last_idx = " << temp_line.last_ << ";\n";
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.line_list{";
            fileMatlab  <<  line_counter   << "}.num_points = " << temp_line.np_ << ";\n";

            fileMatlab << "% Summary of Lines in Object. Each Row is a line containing:  \n";
            fileMatlab << "% || object_count | pt_first_(0) | pt_first_(1) | pt_first_(2) | pt_last_(0) | pt_last_(1) | pt_last_(2) ...\n";
            fileMatlab << "% |vector(0) | vector(1) | vector(2) | error | init idx | last idx ||\n";
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.lines_sum(" << object_count << ",:) = ["    << object_count    <<  ", "
                        << temp_line.point_first_(0)    << "," << temp_line.point_first_(1) << "," << temp_line.point_first_(2) << ", "
                        << temp_line.point_last_(0)     << "," << temp_line.point_last_(1)  << "," << temp_line.point_last_(2)  << ", "
                        << temp_line.vector_(0)         << "," << temp_line.vector_(1)      << "," << temp_line.vector_(2)      << ", "
                        << temp_line.error_   << ", "   << temp_line.first_  <<   ", "   << temp_line.last_  << ", " << temp_line.np_  << "]; \n";

        }

        unsigned int corner_count = 0;
        for (auto& temp_corner : temp_object.corner_list_)
        {
            corner_count += 1;
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.corner_list{";
            fileMatlab  <<  corner_count   << "}.point = ["
                        << temp_corner.pt_(0) << "," << temp_corner.pt_(1) << "," << temp_corner.pt_(2) << "]; \n";
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.corner_list{";
            fileMatlab  <<  corner_count   << "}.orientation = " << temp_corner.orientation_ << ";\n";
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.object_list{" << object_count << "}.corner_list{";
            fileMatlab  <<  corner_count   << "}.aperture = " << temp_corner.aperture_ << ";\n";

            fileMatlab << "% Summary of Corners in Object. Each Row is a corner containing:  \n";
            fileMatlab << "% ||object_count | point_(0) | point_(1) | point_(2) | orientation | aperture || \n";
            fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.corners_sum(" << object_count << ",:) = ["    << object_count <<  ", "
                        << temp_corner.pt_(0) << "," << temp_corner.pt_(1) << "," << temp_corner.pt_(2) << ","
                        << temp_corner.orientation_ << ", " << temp_corner.aperture_ << "]; \n";

        }
    }

    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.scan_total_points_ = "    << _scan_processed.scan_total_points_      << "; \n";
    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.filtered_total_points_ = " << _scan_processed.filtered_total_points_  << "; \n";
    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.number_of_clusters_ = "   << _scan_processed.number_of_clusters_  << "; \n";
    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.num_points_in_clusters_ = "<< _scan_processed.num_points_in_clusters_  << "; \n";
    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.number_of_valid_clusters_ = " << _scan_processed.number_of_valid_clusters_  << "; \n";
    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.number_of_global_scan_ = " << _scan_processed.number_of_global_scan_  << "; \n";

    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.odom_pos_ = ["
               << _scan_processed.odom_pos_[0]  << ", " << _scan_processed.odom_pos_[1]  << ", " << _scan_processed.odom_pos_[2]  << "]; \n ";

    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.odom_ori_ = ["
               << _scan_processed.odom_ori_[0]  << ", " << _scan_processed.odom_ori_[1]  << ", "
               << _scan_processed.odom_ori_[2]  << ", " << _scan_processed.odom_ori_[3]  << "]; \n ";

    fileMatlab << "scan_processed{"  << _scan_processed.id_ << "}.odom_tf = [" << _scan_processed.odom_eigen_tf_ << "];\n\n";




    fileMatlab.close();
}



void laserscanutils::printAssociationResults(std::vector<std::vector<laserscanutils::AssociationResult> > & _asso_results)
{

    std::cout << std::fixed;
    std::cout << std::setprecision(2);
    std::cout << std::endl << "Association Matrix Result "<< std::endl << "\t [corners | centroids | line_init | line_end ]= : " << std::endl;

    for (int i = 0; i<_asso_results.size(); i++)
    {
        for (int j = 0; j< _asso_results[i].size(); j++)
        {
            std::cout << "[ " << _asso_results[i][j].corner_ << "," << _asso_results[i][j].centroid_ << ","
                      << _asso_results[i][j].line_init_ << "," << _asso_results[i][j].line_end_ << " ] \t";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
}




//****************************************************
//**********     preFilterScan
//****************************************************
void laserscanutils::preFilterScan2homog(const laserscanutils::ScanParams & _params,
                                         const std::vector<float> & _ranges,
                                         Eigen::MatrixXs & _points,
                                         LaserScanProcessed &_scan_processed)
{
    //std::cout << "[PreFiltering SCAN... ";

    unsigned int matPosition = 0;
    float act_range = -1;
    float act_theta = 0.0;

    for(unsigned int i=0; i<_ranges.size(); ++i)
    {
        act_range = _ranges[i];

        if ( (act_range >=_params.range_min_) && (act_range <= _params.range_max_) && !(std::isnan(act_range)) && !(std::isinf(act_range))  )
        {
            act_theta = _params.angle_min_+ _params.angle_step_*(i);

            _points.col(matPosition) << act_range*cos(act_theta), act_range*sin(act_theta), 1;

            matPosition++;
        }
        else
        {
            //std::cout << "Invalid Point: " << scan.ranges[i] << " - index: " << i << std::endl;
        }

    }

    // Filling stats
    _scan_processed.scan_total_points_ = _ranges.size();
    _scan_processed.filtered_total_points_ = matPosition;


    // Conservative resize of the eigen Matrix
    _points.conservativeResize(3, matPosition);



//      // DEBUG:
//    std::cout << std::endl << "[PRE-FILTERING]: TotalPoints: " << _scan_processed.scan_total_points_ << std::endl;
//    std::cout << "[PRE-FILTERING]: filtered_total_points_: " << _scan_processed.filtered_total_points_ << std::endl;
//    std::cout << "[PRE-FILTERING]: matrixResize: " << _points.cols() << std::endl;

   // std::cout << "..DONE] " << std::endl;
}



//****************************************************
//**********     extractClustersInScan
//****************************************************
void laserscanutils::extractClustersInScan(const laserscanutils::LaserObjectDetAlgParams & _alg_params,
                                           const Eigen::MatrixXs & _points,
                                           unsigned int _global_scan_number,
                                           laserscanutils::LaserScanProcessed & _scan_processed
                                           )
{

   // std::cout << "Extracting Clusters... " ;
    _scan_processed.cluster_indxs_.clear();
    _scan_processed.object_list_.clear(); // Assure the object list for the scan is empty.

    std::pair<int,int> seg;      // saves the first and last point for each segment
    laserscanutils::Object temp_object; // objects detected initialization.

    float points_distance = 0.0;
    int count_num_cluster = 0;
    int count_num_valid_cluster = 0;

    // Initial Segment
    seg.first = 0;
    float sq_threshold = pow(_alg_params.cluster_jump_thr_,2.0);

    for (unsigned int col = 1; col < _scan_processed.filtered_total_points_; col++)
    {
        points_distance = ( pow( ( _points(0,col) -_points(0,col-1) ), 2.0 ) + pow( ( _points(1,col) - _points(1,col-1) ), 2.0) );        

        if ( points_distance <=  sq_threshold)  // same segment points
        {
          // Same segment

            // Calculating extrem Points -> Used for those unestructured objects (with no lines found) when finding the bounding Box
            if(_points(0,col-1) < temp_object.min_x_ )
                temp_object.min_x_ = _points(0,col-1);
            if(_points(1,col-1) < temp_object.min_y_ )
                temp_object.min_y_ = _points(1,col-1);

            if(_points(0,col-1) > temp_object.max_x_ )
                temp_object.max_x_ = _points(0,col-1);
            if(_points(1,col-1) > temp_object.max_y_ )
                temp_object.max_y_ = _points(1,col-1);
        }

        else
        {
            // new segment

            seg.second = col-1;            // end of the previous segment

            // check length of the cluster
            if ( ( (seg.second - seg.first)+1 >= _alg_params.cluster_min_num_points_ ) &&
                 ( (seg.second - seg.first)+1 <= _alg_params.cluster_max_num_points_) )
            {
                _scan_processed.cluster_indxs_.push_back(seg);

                // fulfill and add object
                temp_object.first_ = seg.first;
                temp_object.last_  = seg.second;
                temp_object.num_points_ = seg.second - seg.first +1;

                _scan_processed.object_list_.push_back(temp_object);
                _scan_processed.num_points_in_clusters_ += temp_object.num_points_;

                count_num_valid_cluster++;    // count cluster as valid

            } // TODO OPT: else: save the invalid cluster in other vector of bad clusters to further analysis


            count_num_cluster++;    // count any cluster

            // reset min max point values:
            temp_object.max_x_ = -1000.0;
            temp_object.max_y_ = -1000.0;
            temp_object.min_x_ = 1000.0;
            temp_object.min_y_ = 1000.0;

            // Initialize next segment (cluster)
            seg.first = col;
        }

    }


    // LAST POINT close last segment (REPEATS LAST STEP)
    seg.second = _scan_processed.filtered_total_points_-1;
    if (  ((seg.second - seg.first)+1 >= _alg_params.cluster_min_num_points_)  &&  ((seg.second - seg.first)+1 <= _alg_params.cluster_max_num_points_)  )
    {
        _scan_processed.cluster_indxs_.push_back(seg);

        // fulfill and add object
        temp_object.first_ = seg.first;
        temp_object.last_  = seg.second;
        temp_object.num_points_ = seg.second - seg.first +1;
        _scan_processed.object_list_.push_back(temp_object);
        _scan_processed.num_points_in_clusters_ += temp_object.num_points_;

        // reset min max point values:
        temp_object.max_x_ = -1000.0;
        temp_object.max_y_ = -1000.0;
        temp_object.min_x_ = 1000.0;
        temp_object.min_y_ = 1000.0;

        count_num_valid_cluster++;    // count cluster as valid

    }
    count_num_cluster++;    // count any cluster


    // Stats
    _scan_processed.number_of_clusters_ = count_num_cluster;
    _scan_processed.number_of_valid_clusters_ = count_num_valid_cluster;
    _scan_processed.number_of_global_scan_ = _global_scan_number;



//  *** [DEBUG] ****

//    // DEBUG printing clusters indexes
//    std::cout << " = " ;
//    for (auto it_clusters : _scan_processed.cluster_indxs_ )
//    {
//        std::cout << "[" << it_clusters.first << ", " << it_clusters.second << "] - ";
//    }

//    std::cout << "Done!" << std::endl;

}





//****************************************************
//**********     findLinesInCluster
//****************************************************
void laserscanutils::findLinesInCluster(const laserscanutils::ScanParams & _scan_params,
                                        const laserscanutils::LaserObjectDetAlgParams & _alg_params,
                                        const Eigen::MatrixXs & _cluster,
                                        std::list<laserscanutils::Line>& _line_list)
{
    laserscanutils::Line line;
    laserscanutils::Line new_line;
    std::list<laserscanutils::Line>::iterator line_it1, line_it2;
    ScalarT theta;      // for angle between lines

    // cleaning line_list
    _line_list.clear();

    //init random generator -> TODO: Eliminate (this is from previous version of library)
    std::default_random_engine generator(1);
    std::uniform_int_distribution<int> rand_window_overlapping(1,_alg_params.fit_line_window_size_);

    unsigned int ii = _alg_params.fit_line_window_size_-1;
    bool last = false;

    while (last != true)
    {
        if (ii >= _cluster.cols())
        {
            ii = _cluster.cols()-1;
            last = true;
        }
        unsigned int i_from = ii - _alg_params.fit_line_window_size_ + 1;

        //std::cout << "Fitting Line: from " << i_from << " to " << ii << "...";
        fitLine(_cluster.block(0,i_from, 3, _alg_params.fit_line_window_size_), line);

        //if error below stdev, add line to result set
        if ( line.error_ < std::pow(_scan_params.range_std_dev_*_alg_params.fit_line_k_sigmas_,2) )
        {
            //std::cout << "=> YES!" << std::endl;
            line.first_ = i_from;
            line.last_ = ii;
            line.point_first_ = _cluster.col(line.first_);
            line.point_last_ = _cluster.col(line.last_);
            line.np_ = line.last_ - line.first_ + 1;

            _line_list.push_back(line);
        }
        else
        {
            //std::cout << " NO! - Error = " << line.error_ << " > " << _scan_params.range_std_dev_*_alg_params.fit_line_k_sigmas_ << std::endl;
        }
        ii = ii+rand_window_overlapping(generator);
    }

    std::cout << "Lines fitted: " << _line_list.size() ;


    // concatenating lines
    line_it1 = _line_list.begin();

    while ( line_it1 != _line_list.end() )
    {
        line_it2 = line_it1;
        line_it2 ++;
        while (line_it2 != _line_list.end())
        {
            //compute angle between lines 1 and 2
            theta = laserscanutils::angleBetweenLines(*line_it1, *line_it2);

            //Check angle threshold
            if ( theta < _alg_params.fit_line_theta_max_parallel_) //fabs(theta) not required since theta>0
            {
                //compute a new line with all involved points
                fitLine(_cluster.block(0,line_it1->first_, 3, line_it2->last_-line_it1->first_+1), new_line);

                //check if error below a threshold to effectively concatenate
                if ( new_line.error_ < std::pow(_scan_params.range_std_dev_*_alg_params.fit_line_k_sigmas_,2) )
                {
                    //std::cout << "   => lines concatenated";

                    //update line1 as the concatenation of l1 and l2
                    new_line.first_ = line_it1->first_;
                    new_line.last_ = line_it2->last_;
                    new_line.point_first_ = line_it1->point_first_;
                    new_line.point_last_ = line_it2->point_last_;
                    new_line.np_ = new_line.last_ - new_line.first_ + 1;
                    *line_it1 = new_line;

                    //remove l2 from the list
                    line_it2 = _line_list.erase(line_it2);

                    //std::cout << " - line resultant: from "<< new_line.first_ << " to " << new_line.last_ << std::endl;
                    //<< new_line.vector_.transpose() <<  "    ERROR: " << new_line.error_ << std::endl << std::endl;

                }
                else
                {
                    //std::cout << "   => lines NOT concatenated";

                    line_it2++;
                }
            }
            else
            {
                line_it2++;
            }

        } // end while it 2

        // Eliminating intermediate lines
        std::list<Line>::iterator temp_line_it = line_it1;
        line_it1++;
        while ( (temp_line_it->last_ >= line_it1->first_) && (line_it1 != _line_list.end()))
        {
            line_it1 = _line_list.erase(line_it1);
        }


    }  // end while it 1


    // DEBUG TEST
//    // globalizing first and last point (in terms of the whole scan)
//    for (auto list_it1 = _line_list.begin(); list_it1 != _line_list.end(); list_it1++)
//    {
//        //std::cout << " INSIDE FIND LINES #." << std::distance(_line_list.begin(),list_it1) << std::endl;
//        list_it1->first_ += initIndex;
//        list_it1->last_ += initIndex;
//        //list_it1->print();
//        //std::cout << std::endl << std::endl;
//    }


        // DEBUG TEST
//    for (auto list_it1 = _line_list.begin(); list_it1 != _line_list.end(); list_it1++)
//    {
//        list_it1->print();
//        std::cout << std::endl;
//    }



    std::cout << " --> Final Lines In Object: " << _line_list.size() << std::endl << std::endl;

}





//****************************************************
//**********     findCornersInClusterLines
//****************************************************
unsigned int laserscanutils::findCornersInClusterLines(const laserscanutils::LaserObjectDetAlgParams & _obj_det_alg_params,
                                                       const std::list<laserscanutils::Line> & _line_list,
                                                       std::list<laserscanutils::Corner> & _corner_list)
{
    //local variables
    ScalarT theta;
    Corner corner;
    std::list<Line>::const_iterator line_it1, line_it2;

    _corner_list.clear();

    line_it1 = _line_list.begin();

    if (_line_list.size() <2)
    {
        return 0;   // Not enough lines for a normal corner:
        // TODO: Corner as init or final point of line. -> As done in association
    }

    auto last_it = _line_list.end();
    last_it --;

    while ( line_it1 != last_it)
    {

        line_it2 = line_it1;
        line_it2 ++;

        //compute angle between lines 1 and 2
        theta = angleBetweenLines(*line_it1, *line_it2);

        //Check angle threshold
        if ( theta > _obj_det_alg_params.corner_theta_min_)
        {
            // Find the corner as the cross product between lines (intersection of lines in homog)
            corner.pt_ = (line_it1->vector_).cross(line_it2->vector_);

            // normalize corner point to set last component to 1
            corner.pt_ = corner.pt_ / corner.pt_(2);

            //vector from corner to first point of l1
            Eigen::Vector2s v1 = line_it1->point_first_.head(2) - corner.pt_.head(2);

            //compute corner orientation as the angle between v1 and local X, in [-pi,pi]
            corner.orientation_ = atan2(v1(1),v1(0));

            //Compute corner aperture with line_it1->first, corner and line_it2->last
            corner.aperture_ = cornerAperture(line_it1->point_first_, corner.pt_, line_it2->point_last_);

            //set other descriptors
            corner.line_1_ = *line_it1;
            corner.line_2_ = *line_it2;

            //add the corner to the list
            _corner_list.push_back(corner);
        }
        else
            //std::cout << "  ... No Corner! : " << std::endl;

        line_it2 ++;
        line_it1 ++;


    }
    // // DEBUG
    //std::cout << "    ******    CORNERS LIST SIZE: " << _corner_list.size() << std::endl;
}





//****************************************************
//**********     extractFeaturesInObject
//****************************************************
void laserscanutils::extractFeaturesInObject(const Eigen::MatrixXs &_points, laserscanutils::Object &_object)
{

    float longest_line_size = -1;
    int longest_line_idx = -1;

    // Extract points corresponding to the object
    Eigen::MatrixXs points;
    points = _points.block(0,_object.first_,2,_object.num_points_);

    // Find longest line
    if (!_object.line_list_.empty())
    {
        longest_line_size = -1;
        longest_line_idx = -1;
        int counter = -1;

        for (auto line_it : _object.line_list_ )
        {
            counter++;
            if (line_it.length() > longest_line_size)
            {
                longest_line_size = line_it.length();
                longest_line_idx = counter;
            }
        }
    }

    if (longest_line_size > 0.7)
    {
        _object.structured_ = true;

        // Get the longest line
        auto longest_line_it = std::next(_object.line_list_.begin(), longest_line_idx);
        laserscanutils::Line longest_line = *longest_line_it;

        //Get orientation of the longest line to get object Orientation
        Eigen::Vector2s v1 = longest_line.point_first_.head(2) - longest_line.point_last_.head(2);
        _object.obj_orientation_ = std::atan2(v1(1),v1(0));

        // Defining Rectangle (Bounding Box) Size
        // - Rotation Matrix
        Eigen::Matrix2s tf;
        tf << std::cos(_object.obj_orientation_), -1*(std::sin(_object.obj_orientation_)),
              std::sin(_object.obj_orientation_),  std::cos(_object.obj_orientation_);

        // - Points Transformed
        Eigen::MatrixXs pointsRot;
        pointsRot = tf.inverse()*points;

        // - Max and Min coordinates
        Eigen::MatrixXf::Index maxRowX, maxColX, minRowX, minColX, maxRowY, maxColY, minRowY, minColY;
        auto MaxX = pointsRot.row(0).maxCoeff(&maxRowX, &maxColX);
        auto MinX = pointsRot.row(0).minCoeff(&minRowX, &minColX);
        auto MaxY = pointsRot.row(1).maxCoeff(&maxRowY, &maxColY);
        auto MinY = pointsRot.row(1).minCoeff(&minRowY, &minColY);

        // - Object Rectangle definition
        _object.size_x_ = std::abs(MaxX - MinX);
        _object.size_y_ = std::abs(MaxY - MinY);

        _object.object_center_(0) = (MaxX - MinX)/2 + MinX;
        _object.object_center_(1) = (MaxY - MinY)/2 + MinY;
        _object.object_center_ = tf*_object.object_center_; // de-rotation the center

        // Defining Rectangle Polyline
        // - Rotate rectangle corners
        _object.polyline_points_.resize(2,5);
        _object.polyline_points_ << MaxX, MinX, MinX, MaxX, MaxX,
                                    MinY, MinY, MaxY, MaxY, MinY;
        _object.polyline_points_ = tf*_object.polyline_points_;

    }


    else // there are no lines OR line size is not enough -> give rectangle of unstructured Object
    {
        _object.structured_ = false;
        // Find x/y_min/max
        Eigen::MatrixXf::Index maxRowX, maxColX, minRowX, minColX, maxRowY, maxColY, minRowY, minColY;
        auto MaxX = points.row(0).maxCoeff(&maxRowX, &maxColX);
        auto MinX = points.row(0).minCoeff(&minRowX, &minColX);
        auto MaxY = points.row(1).maxCoeff(&maxRowY, &maxColY);
        auto MinY = points.row(1).minCoeff(&minRowY, &minColY);

        // Object Rectangle definition
        _object.size_x_ = std::abs(MaxX - MinX);
        _object.size_y_ = std::abs(MaxY - MinY);

        // - Center
        _object.object_center_(0) = (MaxX - MinX)/2 + MinX;
        _object.object_center_(1) = (MaxY - MinY)/2 + MinY;

        // - Polyline
        _object.polyline_points_.resize(2,5);
        _object.polyline_points_ << MaxX, MinX, MinX, MaxX, MaxX,
                                    MinY, MinY, MaxY, MaxY, MinY;

    }

    // Object Centroid
    _object.ref_centroid_point_(0) = (points.row(0).sum())/_object.num_points_;
    _object.ref_centroid_point_(1) = (points.row(1).sum())/_object.num_points_;
    _object.ref_centroid_point_(2) = 1;



    // Initial References
    if (!_object.corner_list_.empty())
    {
        // the front corner of the object will be the reference
        _object.ref_old_point_ = _object.corner_list_.front().pt_;
        _object.ref_act_point_ = _object.corner_list_.front().pt_;
        _object.ref_type_ = 8;
        _object.ref_position_ = 0;        // referenced corner position in list = 0 = front();
    }
    else
    {
        // if no corners, ref will be the centroid
        _object.ref_old_point_ = _object.ref_centroid_point_;
        _object.ref_act_point_ = _object.ref_centroid_point_;
        _object.ref_type_ = 1;
        _object.ref_position_ = -1;
    }



//    // DEBUG
//    _object.print();

}








//****************************************************
//**********     associateCorners
//****************************************************
void laserscanutils::associateObjects(std::list<laserscanutils::Object> & _prev_objects_list,
                                      std::list<laserscanutils::Object> & _act_objects_list,
                                      float _corner_threshold, float _angle_thr, float _line_ext_threshold)

{
    int num_of_col = _prev_objects_list.size();
    int num_of_row = _act_objects_list.size();

//    std::cout << std::endl << "act vs prev objects = " << num_of_row << " vs " << num_of_col << std::endl;

    // Create the matrix to store the association results [NxMx4]
    std::vector< std::vector< laserscanutils::AssociationResult > >asso_results;
    asso_results.resize( num_of_row, std::vector< laserscanutils::AssociationResult>(num_of_col,1000));

    std::vector< std::vector< laserscanutils::AssociationResult > >asso_results_count;
    asso_results_count.resize( num_of_row, std::vector< laserscanutils::AssociationResult>(num_of_col,0));

    float sq_corner_threshold = pow(_corner_threshold, 2);
    float sq_line_threshold = pow(_line_ext_threshold, 2);

    unsigned int prev_obj = 0;
    unsigned int act_obj = 0;

    bool obj_corner_asso    = false;
    bool obj_init_line_asso = false;
    bool obj_end_line_asso  = false;
    bool obj_centroid_asso  = false;


    for (auto&& act_obj_it : _act_objects_list)
    {
        prev_obj = 0;
        for (auto&& prev_obj_it : _prev_objects_list)
        {
            // reset flags
            obj_corner_asso     = false;
            obj_init_line_asso  = false;
            obj_end_line_asso   = false;
            obj_centroid_asso   = false;

//            std::cout << std::endl << "Comparing Objects " << act_obj <<  " - " << prev_obj;

            // Compare CENTROIDS
            float temp_dist_centroid = std::pow( ( act_obj_it.ref_centroid_point_(0) - prev_obj_it.ref_centroid_point_(0) ), 2.0 ) +
                                            pow( ( act_obj_it.ref_centroid_point_(1) - prev_obj_it.ref_centroid_point_(1) ), 2.0 ) ;

//            // DEBUG
//            std::cout <<  "DISTANCE #Centroids: " << act_obj << " - " << prev_obj << ": " << std::endl;
//            std::cout << "\t\t Centroid Distance = " << temp_dist_centroid << std::endl;

            // Updating Matrices Results
            asso_results[act_obj][prev_obj].centroid_ = std::min(temp_dist_centroid, asso_results[act_obj][prev_obj].centroid_);
            asso_results_count[act_obj][prev_obj].centroid_ += 1;

            if (temp_dist_centroid < sq_corner_threshold)
            {
                obj_centroid_asso  = true;
            }


            // Compare CORNERS LIST if exist
            if ( (act_obj_it.corner_list_.size() != 0) && (prev_obj_it.corner_list_.size() != 0) )
            {

                unsigned int prev_pos = 0;
                unsigned int act_pos = 0;

                for (auto&& act_corner_it : act_obj_it.corner_list_)
                {
                    prev_pos = 0;

                    for (auto&& prev_corner_it : prev_obj_it.corner_list_)
                    {

                        float temp_dist_corner = std::pow( ( act_corner_it.pt_(0) - prev_corner_it.pt_(0) ), 2.0 ) +
                                                      pow( ( act_corner_it.pt_(1) - prev_corner_it.pt_(1) ), 2.0) ;

//                        // DEBUG
//                        std::cout <<  "DISTANCE #corners: " << act_obj << "."<< act_pos << " - " << prev_obj << "." << prev_pos << ": " << std::endl;
//                        std::cout << "\t\t Corner Distance = " << temp_dist_corner << std::endl;

                        // Updating Matrices Results
                        asso_results[act_obj][prev_obj].corner_ = std::min(temp_dist_corner, asso_results[act_obj][prev_obj].corner_);
                        asso_results_count[act_obj][prev_obj].corner_ += 1;

                        if (temp_dist_corner < sq_corner_threshold)
                        {
                            obj_corner_asso =true;

                            // If are associated, prev_scan reference is the actual one too. NO!
//                            act_obj_it.ref_act_point_ = prev_obj_it.ref_act_point;
                        }

                        prev_pos++;
                    }

                    act_pos++;
                }

            }
            //else
                //std::cout << "    =>     NO CORNERS LIST";


            // Compare LINES LIST if exist
            if ( (act_obj_it.line_list_.size() != 0) && (prev_obj_it.line_list_.size() != 0) )
            {

                unsigned int prev_pos = 0;
                unsigned int act_pos = 0;

                for (auto&& act_line_it : act_obj_it.line_list_)
                {
                    prev_pos = 0;

                    for (auto&& prev_line_it : prev_obj_it.line_list_)
                    {
                        // LINES ASSO: ANGLE DIFF
                        float temp_dist_angle = laserscanutils::angleBetweenLines(act_line_it, prev_line_it);

                        // LINES ASSO: INIT POINT DIFF
                        float temp_dist_init_pt = std::pow( ( act_line_it.point_first_(0) - prev_line_it.point_first_(0) ), 2.0 ) +
                                                       pow( ( act_line_it.point_first_(1) - prev_line_it.point_first_(1) ), 2.0) ;

                        // LINES ASSO: FINAL POINT DIFF
                        float temp_dist_final_pt = std::pow( ( act_line_it.point_last_(0) - prev_line_it.point_last_(0) ), 2.0 ) +
                                                        pow( ( act_line_it.point_last_(1) - prev_line_it.point_last_(1) ), 2.0) ;

//                        // DEBUG
//                        std::cout <<  "DISTANCE #lines: " << act_obj << "."<< act_pos << " - " << prev_obj << "." << prev_pos << ": " << std::endl;
//                        std::cout << "\t\t Init Points Distance = " << temp_dist_init_pt << std::endl;
//                        std::cout << "\t\t Final Points Distance = " << temp_dist_final_pt << std::endl;
//                        std::cout << "\t\t ANGLE = " << temp_dist_angle << std::endl;

                        // Updating result Matrices.
                        asso_results[act_obj][prev_obj].line_init_ =  std::min(temp_dist_init_pt, asso_results[act_obj][prev_obj].line_init_);
                        asso_results_count[act_obj][prev_obj].line_init_ += 1;

                        asso_results[act_obj][prev_obj].line_end_  =  std::min(temp_dist_final_pt, asso_results[act_obj][prev_obj].line_end_);
                        asso_results_count[act_obj][prev_obj].line_end_ += 1;

                        if ( (temp_dist_angle < _angle_thr) && (temp_dist_init_pt < sq_line_threshold) )
                        {
                            obj_init_line_asso = true;
                        }

                        if ( (temp_dist_angle < _angle_thr) && (temp_dist_final_pt < sq_line_threshold) )
                        {
                            obj_end_line_asso = true;
                        }

                        prev_pos++;
                    }

                    act_pos++;
                }

            }


            // ASSOCIATION RULES:
            // Check ref_points associated and define the tracking point.

            if (obj_corner_asso || obj_init_line_asso || obj_end_line_asso || obj_centroid_asso)
            {
                std::cout << std::endl << "*****  Association SUMMARY: *****" << std::endl;
                std::cout << "\t OBJECTS: " << act_obj << " && " << prev_obj << std::endl;
                std::cout << "*****  END SUMMARY  *****  " << std::endl;

                act_obj_it.associated_ = true;
                act_obj_it.asso_to_prev_obj_in_pos_ = prev_obj;

                // Check ref_point of the association => Forward propagation (prev -> actual)
                if (act_obj_it.ref_type_ <= prev_obj_it.ref_type_)
                {
                    act_obj_it.ref_act_point_ = prev_obj_it.ref_act_point_;
//                    std::cout << std::endl << "Change Refs:\t OLD_ = " << act_obj_it.ref_old_point_.transpose() << "("<<act_obj_it.ref_type_<<") \n\t\t NEW = "
//                                                                    << act_obj_it.ref_act_point_.transpose() << "("<<prev_obj_it.ref_type_<<") \t\t" << std::endl;

                    act_obj_it.ref_type_ = prev_obj_it.ref_type_;


                }
                else
                {
                    // Added new version for integration => Not really used
                    prev_obj_it.ref_act_point_ = act_obj_it.ref_act_point_;
//                    std::cout << std::endl << "Change Refs Backward:\t OLD = " << prev_obj_it.ref_old_point_.transpose() << "("<<act_obj_it.ref_type_<<") \n\t\t NEW = "
//                                                                    << act_obj_it.ref_act_point_.transpose() << "("<<prev_obj_it.ref_type_<<") \t\t" << std::endl;

                    prev_obj_it.ref_type_= act_obj_it.ref_type_;
                }

//                // Propagating object features:
//                if(act_obj_it.size_x_ < prev_obj_it.size_x_)
//                {
//                    act_obj_it.size_x_ = prev_obj_it.size_x_;
//                }

//                if(act_obj_it.size_y_ < prev_obj_it.size_y_)
//                {
//                    act_obj_it.size_y_ = prev_obj_it.size_y_;
//                }

            }



            prev_obj++;
        }
        act_obj++;

    }

    // DEBUG
    //laserscanutils::printAssociationResults(asso_results);
    //laserscanutils::printAssociationResults(asso_results_count);
}




















